% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pro-infer.R
\name{infer_protein}
\alias{infer_protein}
\title{Protein Inference for Shared Glycopeptides}
\usage{
infer_protein(exp, method = c("parsimony", "share", "unique"))
}
\arguments{
\item{exp}{A \code{glyexp::experiment()} containing glycoproteomics data.}

\item{method}{The method to use for protein inference.
Either \code{unique}, \code{parsimony}, or \code{share}.
Default is \code{parsimony}.}
}
\value{
A \code{glyexp::experiment()} containing with protein infered.
}
\description{
Resolves protein assignment ambiguity when glycopeptides are shared across
multiple proteins. Provides three strategies: retain only unique assignments,
apply parsimony principle, or split shared peptides among all candidate proteins.

The function processes semicolon-delimited protein annotations in the \code{proteins},
\code{genes}, and \code{protein_sites} columns (e.g., "PRO1;PRO2" for shared peptides) and
converts them to singular assignments with corresponding \code{protein}, \code{gene}, and
\code{protein_site} columns.
}
\details{
This function provides three different strategies for handling shared glycopeptides:
\subsection{Unique Method}{

The \strong{unique} method is the most conservative approach. It only retains glycopeptides
that are uniquely assigned to a single protein (i.e., those without ";" in the proteins column).

\strong{Algorithm}: Simple filtering based on protein column content.

\strong{Use cases}:
\itemize{
\item When you need high confidence in protein assignments
\item For exploratory analysis where shared peptides might introduce noise
\item When computational simplicity is preferred
}

\strong{Trade-offs}:
\itemize{
\item Pros: No ambiguity, clean results
\item Cons: Loss of data (shared glycopeptides are discarded)
}
}

\subsection{Parsimony Method}{

The \strong{parsimony} method uses a greedy set cover algorithm to find the minimal set of
proteins that can explain all observed glycopeptides. It then assigns each shared
glycopeptide to the protein with the highest overall coverage.

\strong{Algorithm}:
\enumerate{
\item Greedy selection: Iteratively choose the protein that covers the most uncovered glycopeptides
\item Coverage-based assignment: Assign each glycopeptide to the selected protein with highest total coverage
\item Tie-breaking: If coverage is equal, select the first protein in the original order
}

\strong{Use cases}:
\itemize{
\item Standard protein inference in glycoproteomics
\item When you want to retain all data while minimizing protein redundancy
\item For quantitative analysis where protein count matters
}

\strong{Trade-offs}:
\itemize{
\item Pros: Retains all glycopeptides, uses minimal protein set, biologically motivated
\item Cons: Some assignments may be arbitrary for highly shared peptides
}
}

\subsection{Share Method}{

The \strong{share} method assumes that shared glycopeptides are equally contributed by all
associated proteins. Each shared glycopeptide is split into multiple entries, with
expression values divided equally among the proteins.

\strong{Algorithm}:
\enumerate{
\item Split each glycopeptide into separate entries for each associated protein
\item Divide expression values by the number of associated proteins
\item Create unique variable names using the format "original_variable_protein"
}

\strong{Use cases}:
\itemize{
\item When you need to preserve complete protein-glycopeptide relationships
\item For protein-level quantification where each protein's contribution matters
\item When studying protein isoforms or splice variants
}

\strong{Trade-offs}:
\itemize{
\item Pros: Complete information preservation, expression conservation, explicit modeling of sharing
\item Cons: Increased data size, assumption of equal contribution may not reflect biology
}
}

\subsection{Output Format}{

All methods convert the plural columns (\code{proteins}, \code{genes}, \code{protein_sites}) to
singular equivalents (\code{protein}, \code{gene}, \code{protein_site}), where \code{protein_site}
is converted to integer type. The choice of method depends on your specific
analysis goals and tolerance for data loss versus ambiguity.
}
}
